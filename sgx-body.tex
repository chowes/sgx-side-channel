\section{Background}

\subsection{Intel SGX}

Intel Software Guard Extensions (SGX) is an extension to the Intel architecture designed to allow programs to run securely in an environment where all software on the host machine is potentially untrusted \cite{intel_corporation_intel_2016}. SGX was designed to address the problem of \emph{secure remote computation}, that is, secure execution of software on a remote system controlled by an untrusted party \cite{intel_corporation_intel_2016}. Under this threat model, \emph{all} software on a remote system is potentially malicious, including privileged software such as the operating system and hypervisor. Thus SGX must provide protection to user-level programs from untrusted software running at user level as well as at higher privilege levels \cite{costan_intel_2016}. 

SGX provides confidentiality and integrity guarantees through the use of trusted hardware that sequesters a user-level program into a secure container called an \emph{enclave}, and then proves to a user through \emph{software attestation} that he or she is running unmodified software protected in an enclave by secure hardware \cite{intel_corporation_intel_2016}. In order to provide software attestation, the host machine provides a cryptographic signature certifying an enclave's measurement hash, which is computed on a measurement of its contents after it is loaded and initialized \cite{costan_intel_2016}. The remote user can then verify this signature against an endorsement certificate provided by the hardware manufacturer, and can refuse to load his or her data into an enclave whose measurement hash does not match an expected value \cite{intel_corporation_intel_2016, costan_intel_2016}. Under this threat model, the remote user need only trust the hardware manufacturer responsible for providing the secure hardware and endorsement certificate.

\subsubsection{SGX Enclaves}

The SGX security model is centered around maintaining security-sensitive information in secure containers isolated from the rest of the untrusted host system. SGX accomplishes this through the use of a contiguous range of protected memory called Processor Reserved Memory, which is accessible only via a set of specialized microcode instructions called from within an enclave \cite{costan_intel_2016}. Enclave contents and meta-data are stored in a subset of Processor Reserved Memory called the Enclave Page Cache, which is split into 4 KB pages. Management of enclave pages is delegated to the untrusted host OS or hypervisor, which can manage pages via a limited interface using SGX microcode instructions, but may not access this memory directly. Rather, enclave pages are encrypted while in DRAM, and are decrypted in hardware as they are loaded into the cache by the CPU. Furthermore, memory management decisions made by system software are tracked in order to maintain isolation of protected memory by verifying that enclave pages can only be accessed by enclave code executing in the enclave associated with a given enclave page \cite{intel_corporation_intel_2016, costan_intel_2016, moghimi_cachezoom:_2017}. 

\subsection{Software Side-Channel Attacks}

Side-channel attacks are a class of attacks that leverage information about the physical properties of a system in order to carry out an attack. While physical side-channel attacks against modern hardware are difficult and costly, requiring advanced tools and physical access to the victim machine, software side-channel attacks are inexpensive to deploy and can be executed by anyone with remote or local access to a system \cite{costan_intel_2016}. The software side-channel attacks discussed here exploit hardware and software implementation details to acquire information about memory access patterns, which can be used to infer secrets from an otherwise secure system \cite{gotzfried_cache_2017, schwarz_malware_2017, xu_controlled-channel_2015, shinde_preventing_2015}. Software side-channel attacks are not included in the SGX threat model despite the potential danger these attacks pose in a cloud computing environment, and SGX enclaves are not currently protected against this class of attacks \cite{moghimi_cachezoom:_2017, intel_corporation_tutorial_2015}.

\section{Attacks Against SGX Enclaves}

A number of distinct software side-channel attacks have been demonstrated against SGX enclaves in proof-of-concept attacks. While enclave data is protected in Processor Reserved Memory and is isolated from both OS and user-level processes, memory management and scheduling is deferred to the untrusted OS and/or hypervisor, giving a malicious OS a great degree of control over a victim SGX process and providing fine grained measurement capabilities. Thus, a malicious OS is free to dictate precisely how and when a victim enclave program is scheduled, and on which logical cores. This high magnitude of control over the victim process can be leveraged to create powerful privileged software side-channel attacks against SGX enclaves. 

Moreover, the protection and isolation guarantees provided by SGX extend to malicious programs, meaning that an adversary can use an SGX enclave to launch attacks against a victim enclave running on the same host system. Since even privileged services are oblivious to the contents and behavior of SGX enclaves, the host OS has no means to monitor its SGX enclaves for malicious behavior, and thus cannot protect honest user-level processes from malicious enclave behavior.

\subsection{Cache Timing Attacks}

Caches are small regions of high-speed memory used to store recently accessed data in order to reduce future access times. In modern computers with multiple cache levels, each core has its own first and second (L1 and L2) caches, with a third level (L3) cache shared across all cores. When the CPU needs to access data, accesses may be resolved in a cache (a cache ``hit''), or data may need to be fetched from main memory (a cache ``miss''), at which point it is stored in the cache, evicting older data. Cache accesses are considerably faster than memory accesses that must be resolved in main memory, and so caching data can significantly reduce computation time by reducing reliance on relatively slow main memory accesses. Cache timing attacks exploit the timing differences between cache hits and misses to infer secrets kept by a concurrently executing program by analyzing the victim processes memory access patterns \cite{costan_intel_2016, moghimi_cachezoom:_2017}.  

At a high level, an attacker can take advantage of the difference in access speed by filling a shared cache with data, thereby evicting data used by a victim process, and measuring the time it takes to access this data after a context switch. The attacker can determine which regions of memory were accessed by the victim based on the time it takes to access the data it had previously placed in the cache. Since a block of memory is mapped to a region of cache memory based on its virtual memory address, the attacker can us a cache attack to infer information about the victim's memory usage patterns, which can be used to extract secrets such as encryption keys \cite{moghimi_cachezoom:_2017, gotzfried_cache_2017}.

The Prime+Probe attack is cache attack that can be used to attack a victim process by targeting a shared cache. In a \emph{priming} step, the attack fills the entire shared cache, thereby causing the victim's cached data to be evicted. Next, the attacker waits for the victim process to run, at which point it makes memory accesses that result in attacker memory blocks being evicted from the shared cache. Finally, in a \emph{probe} step, the attacker attempts to access its data, timing memory accesses to determine which blocks of memory were used by the victim process \cite{moghimi_cachezoom:_2017, gotzfried_cache_2017}.

\subsection{Page Fault Attacks}

Similar to cache timing attacks, page fault attacks allow an attacker to derive secrets from a victim program based on memory access patterns. Page fault attacks rely on an attacker having control over memory management, as is the case when an attacker controls a malicious OS on which a victim is executing code in an SGX enclave \cite{intel_corporation_tutorial_2015}. In order to carry out an attack, the attacker first analyzes the victim's code in order to identify input-dependent data accesses and input-dependent control transfers. When the application is run, the attacker restricts access to a set of the victim's pages, causing a page fault to be triggered whenever the victim attempts to access an address on a target page. The attacker can record sequences of target page accesses, and can use this information to run an offline analysis and make inferences about the victim's secrets \cite{xu_controlled-channel_2015, shinde_preventing_2015}.

\subsection{Branch Prediction Analysis}

Modern processors use instruction \emph{pipelining} to fetch and decode instructions while previous instructions are executing. In order to maintain efficiency when a branch is encountered, the processor predicts which instruction will be executed after the branch based on past behavior. The predicted next instruction is fetched before the processor has determined which branch must be taken, and if the prediction is correct pipelined execution can continue as normal. On a branch misprediction the processor must clear the predicted instruction and load the correct instruction before execution can continue. In either case, the outcome is used as the basis for prediction the next time the branch is encountered \cite{aciicmez_power_2007, lee_inferring_2017}. 

An attacker can leverage this behavior to infer information about a victim process through a branch shadowing attack. Briefly, an attacker uses knowledge of a program's structure to construct a ``shadow'', which has branches at the same points in execution as the victim. The attacker can then interrupt the victim process after a branch is encountered and run the shadow program. The attacker can then use timing differences or performance monitoring tools to determine whether the branch predictions made by the processor based on the behavior of the victim led to correct or incorrect predictions of the shadow program's behavior, and can infer information about the victim's execution patterns \cite{lee_inferring_2017}.

\section{Countermeasures}

A number of countermeasures have been proposed, both for future development of secure hardware, and additional security measures that can be employed by security conscious developers working with the current implementation of SGX.

\subsection{T-SGX}

\subsection{SGX-Shield}

\subsection{ORAM}

\subsection{Compiler Techniques}

% zigzagger, pidgeonhole

\subsection{Sanctum}

\section{Future Directions}

\section{Conclusions}
